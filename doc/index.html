<html><head></head><body><h1>Color</h1>

<p>To add colors, you must re-write <code>getColor</code> to convert the number of
iterations required into a color. I have provided a sample palette
to use for this project in <code>palette.s</code>. When generating your own
images, you should experiment with different palettes to customize
your images.</p>

<p><code>getColor</code> has the same function signature as before: it accepts a
number of iterations as its only parameter, and it returns an RGB
value. Before, it converted the number of iterations into a shade of
gray, where the number of iterations was directly mapped to the
intensity of the pixel.</p>

<p>Using a color palette, the number of iterations is used as an index
into a list of colors. One iteration translates into the first color
in the palette, two iterations into the second color, etc. When
<code>getColor</code> runs out of colors in the palette, it wraps around and
starts over with the first color again.</p>

<p>Zero iterations is the sentinel value we used to indicate that the
Mandelbrot calculation never exceeded the bailout value. <code>getColor</code>
should check for this as a special case, and return the value of
<code>black</code> as defined in <code>palette.s</code>. <code>black</code> is defined as zero (the
color black), and is named <code>black</code>, but you can change this color as
part of the palette. For convenience, the instructions will refer to
this color as black, even though you could change it to something
else.</p>

<p>For all other iteration values, it should look up a color using:</p>

<ul>
<li><code>colorIndex = (iterations - 1) % palette_size</code></li>
</ul>

<p>Use the <code>remainder</code> function you wrote in the previous step to make
this calculation.</p>

<p>Once you have computed the color index, you should load the
corresponding color from the palette. Remember the each color value
is 32 bits (4 bytes), so you must account for that when looking up
values inside the palette.</p>
</body></html>